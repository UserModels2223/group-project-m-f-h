---
API: 2.1
OpenSesame: 3.3.12b1
Platform: posix
---
set width 1024
set uniform_coordinates yes
set title "SlimStampen example"
set subject_parity even
set subject_nr 0
set start experiment
set sound_sample_size -16
set sound_freq 48000
set sound_channels 2
set sound_buf_size 1024
set sampler_backend psycho
set round_decimals 2
set mouse_backend psycho
set keyboard_backend psycho
set height 768
set fullscreen no
set form_clicks no
set foreground black
set font_underline no
set font_size 30
set font_italic no
set font_family mono
set font_bold no
set experiment_path "/home/a-j/Documents/group-project-m-f-h"
set disable_garbage_collection yes
set description "The main experiment item"
set coordinates uniform
set compensation 0
set color_backend psycho
set clock_backend psycho
set canvas_backend psycho
set background white

define sequence experiment
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run slimstampen_setup always
	run instructions always
	run learning_session_setup always
	run while_there_is_time_left always
	run save_data always

define sketchpad instructions
	set duration keypress
	set description "Displays stimuli"
	draw textline center=1 color=black font_bold=no font_family=mono font_italic=no font_size=25 html=yes show_if=always text="Welcome (Instructions can be placed here). Press any key to begin." x=0 y=0 z_index=0

define inline_script learning_session_setup
	set description "Executes Python code"
	___run__
	# Start the clock
	var.session_start_time = clock.time()
	
	# Session will run until time_up == True
	var.time_up = False
	
	# Keep track of trial number
	var.trial_num = 1
	
	# Settings
	var.session_duration = 10000000
	var.feedback_duration = 800
	var.inter_trial_interval = 200
	__end__
	set _prepare ""

define inline_script present_trial
	set description "Executes Python code"
	___run__
	trial_start_time = clock.time()
	
	
	# Get next fact from the model
	# Ik denk dat we hier een soort van audio koppel moeten maken naar het fact bestand
	next_fact, new = m.get_next_fact(current_time = trial_start_time)
	prompt = next_fact.question
	answer = next_fact.answer
	
	#Als we weten welke fact welke id heeft kunnen we hier het afspelen op baseren, met dictionary ofzo
	fact_id = next_fact.fact_id
	print(stopwatch.process_time())
	# Show prompt, if the fact has been presented as an audio_visual_fact before, also play the audio file
	my_canvas = Canvas()
	my_canvas.text(prompt, font_size = 30)
	if fact_id in audio_visual_facts:
		my_sampler = Sampler(links_audio[fact_id])
		audio_visual_facts.append(fact_id)
		my_sampler.play()
		
	#If a fact is new, give it a fifty fifty chance to be presented as audio visual
	if new and rand.uniform(0, 1) <= audio_visual_chance:
		my_canvas.text(answer, y = 50, font_size = 20)
		my_sampler = Sampler(links_audio[fact_id])
		audio_visual_facts.append(fact_id)
		print(audio_visual_facts)
		my_sampler.play()
	elif new:
		my_canvas.text(answer, y = 50, font_size = 20)
	
	my_canvas.prepare()
	my_canvas.show()
	
	# Listen for keyboard input and show keypresses on screen as they occur
	my_keyboard = Keyboard()
	keyboard_response = ""
	erased_answer = False
	rt = float("inf")
	
	# Keep listening for key presses until the user presses Enter
	while True:
		key, time = my_keyboard.get_key()
		
		# The first keypress determines the response time
		if keyboard_response == "" and not erased_answer:
			rt = clock.time() - trial_start_time
		
		if key == "return":
			break
			
		if key == "backspace":
			keyboard_response = keyboard_response[:-1]
			# If the answer is completely erased, the RT is no longer informative
			if keyboard_response == "":
				erased_answer = True
				rt = float("inf")
		
		elif key == "space":
			keyboard_response += " "
		
		else:
			keyboard_response += my_keyboard.to_chr(key)
	
		# Update what's on screen'
		my_canvas.clear()
		my_canvas.text(prompt, font_size = 30)
		if new:
			my_canvas.text(answer, y = 50, font_size = 20)
		my_canvas.text(keyboard_response, y = 100)
		my_canvas.prepare()
		my_canvas.show()
		
	
	# Check if the response is correct
	# If the answer is correct, increment how often the fact has been entered correctly
	correct = keyboard_response == answer
	if correct and not new:
		fact_correctness[fact_id] += 1
	elif not new:
		fact_correctness[fact_id] = 0
	
	
	#Save the number of correct and incorrect answer per category
	#Also update the fact presentation chance
	if not new and fact_id in audio_visual_facts:
		if correct and fact_correctness[fact_id] >= times_correct:
			correct_audio_visual += 1
			if stopwatch.process_time() >= update_formula_time and audio_visual_chance < 0.50:
				audio_visual_chance += 0.05
			elif stopwatch.process_time() >= update_formula_time:
				audio_visual_chance += audio_visual_chance * 0.1
			visual_chance = 1.0 - audio_visual_chance
		elif not correct:
			wrong_audio_visual += 1
	elif not new:
		if correct and fact_correctness[fact_id] >= times_correct:
			correct_visual += 1
			if stopwatch.process_time() >= update_formula_time and visual_chance < 0.50:
				visual_chance += 0.05
			elif stopwatch.process_time() >= update_formula_time:
				visual_chance += visual_chance * 0.1
			audio_visual_chance = 1.0 - visual_chance
		elif not correct:
			wrong_visual += 1
	
	# Log response
	response = Response(next_fact, trial_start_time, rt, correct)
	m.register_response(response) 
	
	# Show feedback
	feedback_color = "green" if correct else "red"
	my_canvas.text(keyboard_response, y = 100, color = feedback_color)
	if not correct:
		my_canvas.text(answer, y = 150)
		#Replay the audio for feedback
		if fact_id in audio_visual_facts:
			my_sampler = Sampler(links_audio[fact_id])
			my_sampler.play()
			
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.feedback_duration)
	
	# Clear the screen between trials
	my_canvas.clear()
	my_canvas.prepare()
	my_canvas.show()
	clock.sleep(var.inter_trial_interval)
	
	# Check if time is up
	if clock.time() - var.session_start_time >= var.session_duration:
		var.time_up = True
		
	# Increment trial number
	var.trial_num += 1
	
	#Show how the numbers are at the moment of correct and incorrect
	print("trial number:" +str(var.trial_num))
	print("correct audio visual: " + str(correct_audio_visual))
	print("wrong audio visual: " + str(wrong_audio_visual))
	print("correct visual: " + str(correct_visual))
	print("wrong visual: " + str(wrong_visual))
	print("Audio_visual_chance: " + str(audio_visual_chance))
	print(" ")
	__end__
	set _prepare ""

define inline_script save_data
	set description "Executes Python code"
	___run__
	# Write the SlimStampen data to the OpenSesame log file
	dat = m.export_data()
	log.write(dat)
	__end__
	set _prepare ""

define inline_script slimstampen_setup
	set description ""
	___run__
	import random as rand
	import time as stopwatch
	import numpy as np
	m = SpacingModel()
	
	correct_audio_visual = 0
	wrong_audio_visual = 0
	correct_visual = 0
	wrong_visual = 0
	audio_visual_chance = 0.50
	visual_chance = 0.50
	#Time in seconds that need to have passed from start of experiment for the formula to kick in
	update_formula_time = 120
	#How often a fact has to been answered correctly consecutively to be considdered "learnt"
	times_correct = 3
	amount_of_facts = 53
	fact_correctness = np.zeros(amount_of_facts)
	
	links_audio = dict({1: 'audio_files/car.wav',
						2: 'audio_files/visit.wav', 
						3: 'audio_files/bread.wav',
						4: 'audio_files/blood.wav',
						5: 'audio_files/insect.wav',
						6: 'audio_files/exam.wav',
						7: 'audio_files/elevator.wav',
						8: 'audio_files/industry.wav',
						9: 'audio_files/employee.wav',
						10: 'audio_files/virus.wav',
						11: 'audio_files/dinner.wav',
						12: 'audio_files/investment.wav'
						13: 'audio_files/yes.wav'
						14: 'audio_files/thank you.wav'
						15: 'audio_files/goodbye.wav'
						16: 'audio_files/smile.wav'
						17: 'audio_files/today.wav'
						18: 'audio_files/airport.wav'
						19: 'audio_files/hi.wav'
						20: 'audio_files/nice to meet you.wav'
						21: "audio_files/you're welcome.wav"
						22: 'audio_files/how are you.wav'
						23: 'audio_files/week.wav'
						24: 'audio_files/year.wav'
						25: 'audio_files/yesterday.wav'
						26: 'audio_files/tomorrow.wav'
						27: 'audio_files/can.wav'
						28: 'audio_files/use.wav'
						29: 'audio_files/do.wav'
						30: 'audio_files/far.wav'
						31: 'audio_files/small.wav'
						32: 'audio_files/good.wav'
						33: 'audio_files/beautiful.wav'
						34: 'audio_files/ugly.wav'
						35: 'audio_files/difficult.wav'
						36: 'audio_files/bad.wav'
						37: 'audio_files/near.wav'
						38: 'audio_files/beer.wav'
						39: 'audio_files/wine.wav'
						40: 'audio_files/chicken.wav'
						41: 'audio_files/fish.wav'
						42: 'audio_files/cook.wav'
						43: 'audio_files/engineer.wav'
						44: 'audio_files/doctor.wav'
						45: 'audio_files/nurse.wav'
						46: 'audio_files/teacher.wav'
						47: 'audio_files/programmer.wav'
						48: 'audio_files/salesman.wav'
						49: 'audio_files/good morning.wav'
						50: 'audio_files/good afternoon.wav'
						51: 'audio_files/good evening.wav'
						52: 'audio_files/good night.wav'
						53: 'audio_files/delicious.wav'})
	
	
	audio_visual_facts = []
	# Add some study facts to the model (you could also read them from a CSV file)
	facts = [Fact(1, "car", "carro"),
			Fact(2, "visit", "visita"),
			Fact(3, "bread", "pao"),
			Fact(4, "blood", "sangue"),
			Fact(5, "insect", "inseto"),
			Fact(6, "exam", "exame"),
			Fact(7, "elevator", "elevador"),
			Fact(8, "industry", "industria"),
			Fact(9, "employee", "empregado"),
			Fact(10, "virus", "virus"),
			Fact(11, "dinner", "jantar"),
			Fact(12, "investment", "investimento"),
			Fact(13, "yes", "sim"),
			Fact(14, "thank you", "obrigado"),
			Fact(15, "goodbye", "adeus"),
			Fact(16, "smile", "sorrir"),
			Fact(17, "today", "hoje"),
			Fact(18, "airport", "aeroporto"),
			Fact(19, "hi", "oi"),
			Fact(20, "nice to meet you", "prazer"),
			Fact(21, "you're welcome", "de nada"),
			Fact(22, "how are you", "tudo bem"),
			Fact(23, "week", "semana"),
			Fact(24, "year", "ano"),
			Fact(25, "yesterday", "ontem"),
			Fact(26, "tomorrow", "amanha"),
			Fact(27, "can", "poder"),
			Fact(28, "use", "usar"),
			Fact(29, "do", "fazer"),
			Fact(30, "far", "longe"),
			Fact(31, "small", "pequeno"),
			Fact(32, "good", "bom"),
			Fact(33, "beautiful", "bonito"),
			Fact(34, "ugly", "feio"),
			Fact(35, "difficult", "dificil"),
			Fact(36, "bad", "mau"),
			Fact(37, "near", "perto"),
			Fact(38, "beer", "cerveja"),
			Fact(39, "vinho", "wine"),
			Fact(40, "chicken", "frango"),
			Fact(41, "fish", "peixe"),
			Fact(42, "cook", "cozinheiro"),
			Fact(43, "engineer", "engenheiro"),
			Fact(44, "doctor", "gerente"),
			Fact(45, "nurse", "enfermeira"),
			Fact(46, "teacher", "professora"),
			Fact(47, "programmer", "programador"),
			Fact(48, "salesman", "vendedor"),
			Fact(49, "good morning", "bom dia"),
			Fact(50, "good afternoon", "bom tarde"),
			Fact(51, "good evening", "boa noite"),
			Fact(52, "good night", "boa noite"),
			Fact(53, "delicious", "delicioso"),]
	
	for fact in facts:
		m.add_fact(fact)
	__end__
	___prepare__
	from __future__ import division
	import math
	import pandas as pd
	from collections import namedtuple
	
	Fact = namedtuple("Fact", "fact_id, question, answer")
	Response = namedtuple("Response", "fact, start_time, rt, correct")
	Encounter = namedtuple("Encounter", "activation, time, reaction_time, decay")
	
	
	class SpacingModel(object):
	
	    # Model constants
	    LOOKAHEAD_TIME = 15000
	    FORGET_THRESHOLD = -0.8
	    DEFAULT_ALPHA = 0.3
	    C = 0.25
	    F = 1.0
	
	    def __init__(self):
	        self.facts = []
	        self.responses = []
	
	    def add_fact(self, fact):
	        # type: (Fact) -> None
	        """
	        Add a fact to the list of study items.
	        """
	        # Ensure that a fact with this ID does not exist already
	        if next((f for f in self.facts if f.fact_id == fact.fact_id), None):
	            raise RuntimeError(
	                "Error while adding fact: There is already a fact with the same ID: {}. Each fact must have a unique ID".format(fact.fact_id))
	
	        self.facts.append(fact)
	
	
	    def register_response(self, response):
	        # type: (Response) -> None
	        """
	        Register a response.
	        """
	        # Prevent duplicate responses
	        if next((r for r in self.responses if r.start_time == response.start_time), None):
	            raise RuntimeError(
	                "Error while registering response: A response has already been logged at this start_time: {}. Each response must occur at a unique start_time.".format(response.start_time))
	
	        self.responses.append(response)
	
	
	    def get_next_fact(self, current_time):
	        # type: (int) -> (Fact, bool)
	        """
	        Returns a tuple containing the fact that needs to be repeated most urgently and a boolean indicating whether this fact is new (True) or has been presented before (False).
	        If none of the previously studied facts needs to be repeated right now, return a new fact instead.
	        """
	        # Calculate all fact activations in the near future
	        fact_activations = [(f, self.calculate_activation(current_time + self.LOOKAHEAD_TIME, f)) for f in self.facts]
	
	        seen_facts = [(f, a) for (f, a) in fact_activations if a > -float("inf")]
	        not_seen_facts = [(f, a) for (f, a) in fact_activations if a == -float("inf")]
	
	        # Prevent an immediate repetition of the same fact
	        if len(seen_facts) > 2:
	            last_response = self.responses[-1]
	            seen_facts = [(f, a) for (f, a) in seen_facts if f.fact_id != last_response.fact.fact_id]
	
	        # Reinforce the weakest fact with an activation below the threshold
	        seen_facts_below_threshold = [(f, a) for (f, a) in seen_facts if a < self.FORGET_THRESHOLD]
	        if len(not_seen_facts) == 0 or len(seen_facts_below_threshold) > 0:
	            weakest_fact = min(seen_facts, key = lambda t: t[1])
	            return((weakest_fact[0], False))
	
	        # If none of the previously seen facts has an activation below the threshold, return a new fact
	        return((not_seen_facts[0][0], True))
	
	
	    def get_rate_of_forgetting(self, time, fact):
	        # type: (int, Fact) -> float
	        """
	        Return the estimated rate of forgetting of the fact at the specified time
	        """
	        encounters = []
	
	        responses_for_fact = [r for r in self.responses if r.fact.fact_id == fact.fact_id and r.start_time < time]
	        alpha = self.DEFAULT_ALPHA
	
	        # Calculate the activation by running through the sequence of previous responses
	        for response in responses_for_fact:
	            activation = self.calculate_activation_from_encounters(encounters, response.start_time)
	            encounters.append(Encounter(activation, response.start_time, self.normalise_reaction_time(response), self.DEFAULT_ALPHA))
	            alpha = self.estimate_alpha(encounters, activation, response, alpha)
	
	            # Update decay estimates of previous encounters
	            encounters = [encounter._replace(decay = self.calculate_decay(encounter.activation, alpha)) for encounter in encounters]
	
	        return(alpha)
	
	
	    def calculate_activation(self, time, fact):
	        # type: (int, Fact) -> float
	        """
	        Calculate the activation of a fact at the given time.
	        """
	
	        encounters = []
	
	        responses_for_fact = [r for r in self.responses if r.fact.fact_id == fact.fact_id and r.start_time < time]
	        alpha = self.DEFAULT_ALPHA
	
	        # Calculate the activation by running through the sequence of previous responses
	        for response in responses_for_fact:
	            activation = self.calculate_activation_from_encounters(encounters, response.start_time)
	            encounters.append(Encounter(activation, response.start_time, self.normalise_reaction_time(response), self.DEFAULT_ALPHA))
	            alpha = self.estimate_alpha(encounters, activation, response, alpha)
	
	            # Update decay estimates of previous encounters
	            encounters = [encounter._replace(decay = self.calculate_decay(encounter.activation, alpha)) for encounter in encounters]
	
	        return(self.calculate_activation_from_encounters(encounters, time))
	
	
	    def calculate_decay(self, activation, alpha):
	        # type: (float, float) -> float
	        """
	        Calculate activation-dependent decay
	        """
	        return self.C * math.exp(activation) + alpha
	
	
	    def estimate_alpha(self, encounters, activation, response, previous_alpha):
	        # type: ([Encounter], float, Response, float) -> float
	        """
	        Estimate the rate of forgetting parameter (alpha) for an item.
	        """
	        if len(encounters) < 3:
	            return(self.DEFAULT_ALPHA)
	
	        a_fit = previous_alpha
	        reading_time = self.get_reading_time(response.fact.question)
	        estimated_rt = self.estimate_reaction_time_from_activation(activation, reading_time)
	        est_diff = estimated_rt - self.normalise_reaction_time(response)
	
	        if est_diff < 0:
	            # Estimated RT was too short (estimated activation too high), so actual decay was larger
	            a0 = a_fit
	            a1 = a_fit + 0.05
	        
	        else:
	            # Estimated RT was too long (estimated activation too low), so actual decay was smaller
	            a0 = a_fit - 0.05
	            a1 = a_fit
	
	        # Binary search between previous fit and proposed alpha
	        for _ in range(6):
	            # Adjust all decays to use the new alpha
	            a0_diff = a0 - a_fit
	            a1_diff = a1 - a_fit
	            d_a0 = [e._replace(decay = e.decay + a0_diff) for e in encounters]
	            d_a1 = [e._replace(decay = e.decay + a1_diff) for e in encounters]
	
	            # Calculate the reaction times from activation and compare against observed RTs
	            encounter_window = encounters[max(1, len(encounters) - 5):]
	            total_a0_error = self.calculate_predicted_reaction_time_error(encounter_window, d_a0, reading_time)
	            total_a1_error = self.calculate_predicted_reaction_time_error(encounter_window, d_a1, reading_time)
	
	            # Adjust the search area based on the lowest total error
	            ac = (a0 + a1) / 2
	            if total_a0_error < total_a1_error:
	                a1 = ac
	            else:
	                a0 = ac
	        
	        # The new alpha estimate is the average value in the remaining bracket
	        return((a0 + a1) / 2)
	
	
	    def calculate_activation_from_encounters(self, encounters, current_time):
	        # type: ([Encounter], int) -> float
	        included_encounters = [e for e in encounters if e.time < current_time]
	
	        if len(included_encounters) == 0:
	            return(-float("inf"))
	
	        return(math.log(sum([math.pow((current_time - e.time) / 1000, -e.decay) for e in included_encounters])))
	
	
	    def calculate_predicted_reaction_time_error(self, test_set, decay_adjusted_encounters, reading_time):
	        # type: ([Encounter], [Encounter], Fact) -> float
	        """
	        Calculate the summed absolute difference between observed response times and those predicted based on a decay adjustment.
	        """
	        activations = [self.calculate_activation_from_encounters(decay_adjusted_encounters, e.time - 100) for e in test_set]
	        rt = [self.estimate_reaction_time_from_activation(a, reading_time) for a in activations]
	        rt_errors = [abs(e.reaction_time - rt) for (e, rt) in zip(test_set, rt)]
	        return(sum(rt_errors))
	
	
	    def estimate_reaction_time_from_activation(self, activation, reading_time):
	        # type: (float, int) -> float
	        """
	        Calculate an estimated reaction time given a fact's activation and the expected reading time 
	        """
	        return((self.F * math.exp(-activation) + (reading_time / 1000)) * 1000)
	
	
	    def get_max_reaction_time_for_fact(self, fact):
	        # type: (Fact) -> float
	        """
	        Return the highest response time we can reasonably expect for a given fact
	        """
	        reading_time = self.get_reading_time(fact.question)
	        max_rt = 1.5 * self.estimate_reaction_time_from_activation(self.FORGET_THRESHOLD, reading_time)
	        return(max_rt)
	
	
	    def get_reading_time(self, text):
	        # type: (str) -> float
	        """
	        Return expected reading time in milliseconds for a given string
	        """
	        word_count = len(text.split())
	
	        if word_count > 1:
	            character_count = len(text)
	            return(max((-157.9 + character_count * 19.5), 300))
	        
	        return(300)
	
	    
	    def normalise_reaction_time(self, response):
	        # type: (Response) -> float
	        """
	        Cut off extremely long responses to keep the reaction time within reasonable bounds
	        """
	        rt = response.rt if response.correct else 60000
	        max_rt = self.get_max_reaction_time_for_fact(response.fact)
	        return(min(rt, max_rt))
	
	
	    def export_data(self, path = None):
	        # type: (str) -> DataFrame
	        """
	        Save the response data to the specified csv file, and return a copy of the pandas DataFrame.
	        If no path is specified, return a CSV-formatted copy of the data instead.
	        """
	
	        def calc_rof(row):
	            return(self.get_rate_of_forgetting(row["start_time"] + 1, row["fact"]))
	
	        dat_resp = pd.DataFrame(self.responses)
	        dat_facts = pd.DataFrame([r.fact for r in self.responses])
	        dat = pd.concat([dat_resp, dat_facts], axis = 1)
	
	        # Add column for rate of forgetting estimate after each observation
	        dat["alpha"] = dat.apply(calc_rof, axis = 1)
	        dat.drop(columns = "fact", inplace = True)
	
	        # Add trial number column
	        dat.index.name = "trial"
	        dat.index = dat.index + 1
	
	        # Save to CSV file if a path was specified, otherwise return the CSV-formatted output
	        if path is not None:
	            dat.to_csv(path, encoding="UTF-8")
	            return(dat)
	        
	        return(dat.to_csv())
	__end__

define sequence trial_sequence
	set flush_keyboard yes
	set description "Runs a number of items in sequence"
	run present_trial always

define loop while_there_is_time_left
	set source table
	set repeat 1000
	set order random
	set description "Repeatedly runs another item"
	set cycles 1
	set continuous no
	set break_if_on_first yes
	set break_if "[time_up] = yes"
	setcycle 0 ignore_this_variable 1
	run trial_sequence

